import os
import shutil
from build_config import PUBLIC_API_FILES, IGNORE_DIRS

# Check environment variable for Cython compilation
COMPILE_CYTHON = os.getenv('COMPILE_CYTHON', 'false').lower() == 'true'

def cleanup_compiled_files():
    """
    Cleans up source files after compilation:
    - Removes .py files that have corresponding .so files (except __init__.py and API files)
    - Removes .c files generated by Cython
    - Removes .pyc files and __pycache__ directories
    """
    print("\n=== Cleanup Debug Information ===")
    print(f"Current working directory: {os.getcwd()}")
    print(f"COMPILE_CYTHON is set to: {COMPILE_CYTHON}")
    
    # Convert PUBLIC_API_FILES paths to absolute paths for better matching
    public_api_files = {path for path in PUBLIC_API_FILES if path.endswith('.py')}
    print(f"Protected API files: {public_api_files}")
    print("================================\n")

    for root, dirs, files in os.walk('.'):
        print(f"\nProcessing directory: {root}")
        
        # Skip ignored directories
        dirs[:] = [d for d in dirs if d not in IGNORE_DIRS]
        
        # Get list of .so files in this directory
        so_files = {os.path.splitext(f)[0] for f in files if f.endswith('.so')}
        
        for file in files:
            filepath = os.path.join(root, file)
            relative_path = filepath[2:].replace('\\', '/')  # Remove ./ and normalize slashes
            
            # Always remove .c files (Cython intermediates)
            if file.endswith('.c'):
                print(f"Removing {filepath}")
                os.remove(filepath)
                continue
                
            # Always remove .pyc files
            if file.endswith('.pyc'):
                print(f"Removing {filepath}")
                os.remove(filepath)
                continue
            
            # Only remove .py files if COMPILE_CYTHON is True AND
            # there's a corresponding .so file
            if COMPILE_CYTHON and file.endswith('.py'):
                basename = os.path.splitext(file)[0]
                if (basename in so_files and  # Has corresponding .so file
                    relative_path not in public_api_files and 
                    file != '__init__.py'):
                    print(f"Removing Python file: {filepath}")
                    os.remove(filepath)
                else:
                    if file != '__init__.py':
                        print(f"Keeping Python file: {filepath} (no .so file found)")
                    else:
                        print(f"Keeping protected Python file: {filepath}")

if __name__ == '__main__':
    cleanup_compiled_files() 