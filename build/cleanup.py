import os
import shutil
from build_config import PUBLIC_API_FILES, IGNORE_DIRS

# Check environment variable for Cython compilation
COMPILE_CYTHON = os.getenv('COMPILE_CYTHON', 'false').lower() == 'true'

def cleanup_compiled_files():
    """
    Cleans up source files after compilation:
    - Removes .py files that have corresponding .so files (except __init__.py and API files)
    - Removes .c files generated by Cython
    - Removes .pyc files and __pycache__ directories
    """
    print("\n=== Cleanup Debug Information ===")
    print(f"Current working directory: {os.getcwd()}")
    print(f"COMPILE_CYTHON is set to: {COMPILE_CYTHON}")
    
    # Convert PUBLIC_API_FILES paths to absolute paths for better matching
    public_api_files = {path for path in PUBLIC_API_FILES if path.endswith('.py')}
    print(f"Protected API files: {public_api_files}")
    print("================================\n")

    # Define binary extensions for different platforms
    BINARY_EXTENSIONS = ('.so', '.pyd', '.dylib')
    
    for root, dirs, files in os.walk('.'):
        print(f"\nProcessing directory: {root}")
        
        # Skip ignored directories
        dirs[:] = [d for d in dirs if d not in IGNORE_DIRS]
        
        # Get list of compiled binary files in this directory
        compiled_files = {
            os.path.splitext(f)[0] for f in files 
            if any(f.endswith(ext) for ext in BINARY_EXTENSIONS)
        }
        
        for file in files:
            filepath = os.path.join(root, file)
            relative_path = filepath[2:].replace('\\', '/')  # Remove ./ and normalize slashes
            
            # Always remove .c files (Cython intermediates)
            if file.endswith('.c'):
                print(f"Removing {filepath}")
                os.remove(filepath)
                continue
                
            # Always remove .pyc files
            if file.endswith('.pyc'):
                print(f"Removing {filepath}")
                os.remove(filepath)
                continue
            
            # Handle Python source files
            if COMPILE_CYTHON and file.endswith('.py'):
                basename = os.path.splitext(file)[0]
                if (basename in compiled_files and
                    relative_path not in public_api_files and 
                    file != '__init__.py'):
                    print(f"Removing Python file: {filepath}")
                    os.remove(filepath)
                else:
                    if file != '__init__.py':
                        print(f"Keeping Python file: {filepath} (no binary file found)")
                    else:
                        print(f"Keeping protected Python file: {filepath}")

if __name__ == '__main__':
    cleanup_compiled_files() 