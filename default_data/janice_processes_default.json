{
  "janice_formula1_data_golden": {
    "BOT_ID": "Janice",
    "PROCESS_NAME": "janice_formula1_data",
    "PROCESS_INSTRUCTIONS": "1. Search the Snowflake database for tables or views that contain Formula 1 data.\n2. Locate a table or view with DRIVER information.\n3. Query the identified table or view to find the driver with the most wins.\n4. Post the result to the channel #C075LL9KPM3.",
    "PROCESS_DETAILS": "Search Formula 1 Data",
    "TIMESTAMP": "2000-01-01T00:00:00.000Z"
  },
  "janice_warehouse_sizing_recommendation_golden": {
    "BOT_ID": "Janice",
    "PROCESS_NAME": "janice_assisted_user_creation",
    "PROCESS_INSTRUCTIONS": "\n1. Retrieve query history data and calculate average queuing time per hour for each warehouse.\n2. Identify warehouses with average queuing time per hour exceeding 60,000 microseconds.\n3. Display the top 3 warehouses with the highest total queuing times for reference.\n4. Analyze the query history to compute the average swapping to disk per query.\n5. Identify warehouses with an average swapping to disk per query exceeding 100MB (104,857,600 bytes).\n6. Display the top 3 warehouses with the highest average swapping to disk per query for a spot check, regardless of the threshold.\n7. Send an email summary of the analysis to matt@genesiscomputing.ai every Friday at 9 am ET, including recommendations for which warehouses should be made multi-cluster or resized, DataCube URLs for both queuing and swapping spot checks, and the process ID for reference.\n8. Add a description at the top of the email to explain the purpose of the email for future recipients.\n",
    "PROCESS_DETAILS": "Analyze Warehouse Queuing and Swapping",
    "TIMESTAMP": "2000-01-01T00:00:00.000Z"
  },
  "janice_monitor_unused_tables_golden": {
    "BOT_ID": "Janice",
    "PROCESS_NAME": "janice_assisted_user_creation",
    "PROCESS_INSTRUCTIONS": "# Monitor Unused Tables - New Process Description\n\n## Overview\nThis process identifies and notifies stakeholders about unused tables within Snowflake databases. It uses AGGREGATE_ACCESS_HISTORYfor comprehensive monitoring and to minimize false positives.\n\n## Process Steps:\n\n1. Check for Table Existence:\n   - Ensure the ignore list table exists.\n   - SQL Query: CREATE TABLE IF NOT EXISTS GENESIS_BOTS_ALPHA.JANICE_7G8H9J_WORKSPACE.MONITOR_UNUSED_TABLES_IGNORE_LIST (DATABASE_NAME STRING, TABLE_SCHEMA STRING, TABLE_NAME STRING);\n\n2. Fetch List of Tables:\n   - Retrieve a complete list of tables across all databases and schemas, excluding those in the ignore list.\n   - SQL Query: SELECT DATABASE_NAME, TABLE_SCHEMA, TABLE_NAME FROM SNOWFLAKE.INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE IN ('BASE TABLE', 'MATERIALIZED VIEW') AND (TABLE_SCHEMA, TABLE_NAME) NOT IN (SELECT TABLE_SCHEMA, TABLE_NAME FROM GENESIS_BOTS_ALPHA.JANICE_7G8H9J_WORKSPACE.MONITOR_UNUSED_TABLES_IGNORE_LIST WHERE DATABASE_NAME = 'GENESIS_BOTS_ALPHA');\n\n3. Check AGGREGATE_ACCESS_HISTORY:\n   - Verify that AGGREGATE_ACCESS_HISTORY is not empty.\n   - SQL Query: SELECT COUNT(*) FROM SNOWFLAKE.ACCOUNT_USAGE.AGGREGATE_ACCESS_HISTORY;\n   - Action: If count is zero, send an error email indicating the account type is likely not enterprise edition, then exit the process.\n\n4. Analyze Access Patterns:\n   - Determine table usage through access history.\n   - SQL Query: WITH AccessedTables AS (SELECT f.value:objectName::string AS TABLE_NAME FROM SNOWFLAKE.ACCOUNT_USAGE.AGGREGATE_ACCESS_HISTORY, TABLE(FLATTEN(INPUT => DIRECT_OBJECTS_ACCESSED)) f WHERE DIRECT_OBJECTS_ACCESSED IS NOT NULL AND INTERVAL_START_TIME > CURRENT_TIMESTAMP - INTERVAL '30 days' GROUP BY TABLE_NAME)\n\n5. Identify Unused Tables:\n   - Compile a list of tables that haven't been accessed within a predefined period.\n   - SQL Query: (Complex query to identify unused tables, omitted for brevity)\n\n6. Optional Notification:\n   - Notify relevant stakeholders about the identified unused tables.\n   - Prepare content based on results from above queries.\n\n7. Include Cleanup Suggestions in Email:\n   - Provide suggestions for further optimization.\n   - Add cleanup suggestions and include a placeholder link for users to access additional analysis.\n   - Placeholder Link: <https://app.snowflake.com/genesis_placeholder?bot_id=BOT_ID&thread_id=THREAD_ID>\n\n## Conclusion\nThis process streamlines the identification of unused tables, enabling effective cleanup and resource management within the Snowflake environment.\n\n## Example Email Output Structure\n- Subject: Unused Tables Across Snowflake Databases\n- Body: (Example email body structure)",
    "PROCESS_DETAILS": "Monitor Unused Tables",
    "TIMESTAMP": "2000-01-01T00:00:00.000Z"
  },
  "janice_data_freshness_check_golden": {
    "BOT_ID": "Janice",
    "PROCESS_NAME": "janice_data_freshness_check",
    "PROCESS_INSTRUCTIONS": "\n**Process:  Check for data freshness** 1. **Find tables** - Check the processes table for this process and confirm that process_config has data.  - If process_config does not have any data, inform the user and show the user a list of the names of all of the database tables you have access to.  - Ask the user which tables they want to use and update the process_config field to reflect these choices. 2. **Find latest updates in each table with more than the number of rows specified in the parameter table_cutoff_size** -Sort each table in the process_config field with more than table_cutoff_size in descending order by latest update date.  3.  **Find n tables with the oldest dates** -Using the first row of each table, find the n tables with the oldest dates where n is a parameter called unfresh_table_count.  4. **Report back to user** -Report the n tables names and update date in ascending order.",
    "PROCESS_DETAILS": "Data Freshness Check",
    "PROCESS_PARAMS": "TABLE_A, TABLE_B, TABLE_C",
    "TIMESTAMP": "2000-01-01T00:00:00.000Z"
  },
  "janice_dangerous_user_report_golden": {
    "BOT_ID": "janice-7g8h9j",
    "PROCESS_INSTRUCTIONS": "1. Run the following SQL query to gather data on user roles and privileges:\n\n```WITH role_hier AS (\n    SELECT\n        grantee_name,\n        name\n    FROM\n        SNOWFLAKE.ACCOUNT_USAGE.GRANTS_TO_ROLES\n    WHERE\n        granted_on = 'ROLE'\n        AND privilege = 'USAGE'\n        AND deleted_on IS NULL\n    UNION ALL\n    SELECT\n        'root',\n        r.name\n    FROM\n        SNOWFLAKE.ACCOUNT_USAGE.ROLES r\n    WHERE\n        deleted_on IS NULL\n        AND NOT EXISTS (\n            SELECT\n                1\n            FROM\n                SNOWFLAKE.ACCOUNT_USAGE.GRANTS_TO_ROLES gtr\n            WHERE\n                gtr.granted_on = 'ROLE'\n                AND gtr.privilege = 'USAGE'\n                AND gtr.name = r.name\n                AND deleted_on IS NULL\n        )\n),\nrole_path_pre AS (\n    SELECT\n        name,\n        level,\n        sys_connect_by_path(name, ' -&gt; ') AS path\n    FROM\n        role_hier CONNECT BY grantee_name = PRIOR name START WITH grantee_name = 'root'\n    ORDER BY\n        path\n),\nrole_path AS (\n    SELECT\n        name,\n        level,\n        substr(path, len(' -&gt; ')) AS path\n    FROM\n        role_path_pre\n),\nrole_path_privs AS (\n    SELECT\n        path,\n        rp.name AS role_name,\n        privs.privilege,\n        granted_on,\n        CASE\n            WHEN privs.granted_on = 'ROLE' THEN 'Yes'\n            WHEN privs.granted_on IS NULL AND path LIKE '%-&gt;%' THEN 'Yes'\n            ELSE NULL\n        END AS is_grant_to_role,\n        CASE\n            WHEN privs.granted_on != 'ROLE' THEN 'Yes'\n            WHEN privs.granted_on IS NULL AND path NOT LIKE '%-&gt;%' THEN 'Yes'\n            ELSE NULL\n        END AS is_grant_to_privs,\n        privs.name AS priv_name,\n        'Role ' || path || ' has ' || privilege || ' on ' || granted_on || ' ' || privs.name AS Description\n    FROM\n        role_path rp\n        LEFT JOIN SNOWFLAKE.ACCOUNT_USAGE.GRANTS_TO_ROLES privs ON rp.name = privs.grantee_name\n        AND deleted_on IS NULL\n    ORDER BY\n        path\n),\nrole_path_privs_agg AS (\n    SELECT\n        TRIM(SPLIT(path, ' -&gt; ')[0]) role,\n        COUNT(*) num_of_privs,\n        COUNT(is_grant_to_role) num_role_grants,\n        COUNT(is_grant_to_privs) num_privs_grants\n    FROM\n        role_path_privs\n    GROUP BY\n        TRIM(SPLIT(path, ' -&gt; ')[0])\n    ORDER BY\n        COUNT(*) DESC\n),\naccountadmin_check AS (\n    SELECT\n        grantee_name AS user_name,\n        MAX(CASE WHEN role = 'ACCOUNTADMIN' THEN TRUE ELSE FALSE END) AS has_accountadmin\n    FROM\n        SNOWFLAKE.ACCOUNT_USAGE.GRANTS_TO_USERS\n    GROUP BY\n        grantee_name\n)\nSELECT\n    current_timestamp() AS timestamp,\n    u.grantee_name AS user,\n    COUNT(a.role) AS Direct_Role_Grants,\n    SUM(num_role_grants) AS Total_Role_Grants,\n    SUM(num_privs_grants) AS Total_Privs_Grants,\n    SUM(num_of_privs) AS All_Grant_Types,\n    COALESCE(ac.has_accountadmin, FALSE) AS has_accountadmin -- Added the ACCOUNTADMIN check\nFROM\n    SNOWFLAKE.ACCOUNT_USAGE.GRANTS_TO_USERS u\n    JOIN role_path_privs_agg a ON a.role = u.role\n    LEFT JOIN accountadmin_check ac ON u.grantee_name = ac.user_name -- Join with ACCOUNTADMIN check\nWHERE\n    u.deleted_on IS NULL\nGROUP BY\n    u.grantee_name, ac.has_accountadmin\nORDER BY\n    All_Grant_Types DESC;```\n\n2. Analyze the results based on the following criteria:\n   - Identify the top 3 users in terms of total privileges granted inclusive of roles. If the top users all have ACCOUNTADMIN role then be sure to note that.\n   - Determine if the rights and roles are concentrated in a few specific users or more evenly spread out. If the roles are concentrated and the users with the concentrated power also have ACCOUNTADMIN role, then note that as a possible cause of their having so much power.\n   - Check how broadly the ACCOUNTADMIN role is granted. ACCOUNTADMIN is the single most powerful role in Snowflake, and granting it too widely is very bad practice which should be discouraged.\n   - Look for any unusual patterns or noteworthy observations in the results. are there many users with similar numbers? are there only a few users with most rights and the rest have very little? MAKE SURE TO SAY IF THERE are there any ways that ACCOUNTADMIN grants may be warping the data? are there any other things about the numbers which seems noteworthy?\n\n3. Report the findings, including any significant observations about the distribution of privileges and the granting of the ACCOUNTADMIN role.",
    "PROCESS_NAME": "Dangerous User Report",
    "PROCESS_PARAMS": "TABLE_A, TABLE_B, TABLE_C",
    "TIMESTAMP": "2024-09-09 11:43:39.460 -0700"
  },
  "janice_check_MFA_use_in_snowflake_golden": {
      "BOT_ID": "janice-7g8h9j",
      "PROCESS_INSTRUCTIONS": "Below is the reviewed and organized process with clear steps, properly formatted and tidy:\n\n---\n\n**Process for Evaluating User MFA and Type Adoption in Snowflake**\n\n1. **Query to Retrieve User Data**:\n   - Run the following SQL query to collect necessary data:\n   ```sql\n   SELECT NAME, HAS_PASSWORD, EXT_AUTHN_DUO, TYPE\n   FROM SNOWFLAKE.ACCOUNT_USAGE.USERS\n   WHERE HAS_PASSWORD = TRUE;\n   ```\n\n2. **Analyze MFA Usage**:\n   - Calculate the total number of users with passwords set.\n   - Calculate the number and percentage of users with passwords set who have MFA enabled.\n   - Interpret results and provide recommendations based on MFA adoption rate.\n\n3. **Analyze User Type Adoption**:\n   - Calculate the number and percentage of users with the `TYPE` attribute set.\n   - Identify `PERSON` type users and check how many of them have MFA enabled.\n   - Provide insights on the importance of setting the `TYPE` attribute and ensuring MFA for `PERSON` type users.\n\n4. **Create Visual Representation**:\n   - Create an ASCII art bar chart to visualize the adoption rates of MFA and `TYPE` attribute.\n   - Ensure the chart includes a scale up to 100% so that the size of the bars shows how close or far they are from the goal of 100%.\n\n5. **Generate Report and Recommendations**:\n   - Summarize findings in a report format.\n   - Highlight key findings and provide recommendations to improve security practices, such as increasing MFA adoption and setting user types.\n\n### Example of Generated ASCII Art Bar Chart:\n```\nMFA Adoption (Goal: 100%)\n| ██████████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒  20%\n\nTYPE Set (Goal: 100%)\n| ██▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒  5%\n\nPERSON Users with MFA (Goal: 100%)\n| ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒  0%\n```\n\n### End of Process\n\n---",
      "PROCESS_NAME": "Check MFA Use in Snowflake",
      "PROCESS_PARAMS": "TABLE_A, TABLE_B, TABLE_C",
      "TIMESTAMP": "2024-09-09 11:43:39.460 -0700"
  },
  "janice_auth_failure_report_golden": {
      "BOT_ID": "Janice",
      "PROCESS_NAME": "janice_auth_failure_report",
      "PROCESS_INSTRUCTIONS": "Below is the reviewed and organized process with clear steps, properly formatted and tidy: --- **Process for Evaluating User MFA and Type Adoption in Snowflake** 1. **Query to Retrieve User Data**: - Run the following SQL query to collect necessary data:```sql SELECT NAME, HAS_PASSWORD, EXT_AUTHN_DUO, TYPE FROM SNOWFLAKE.ACCOUNT_USAGE.USERS WHERE HAS_PASSWORD = TRUE;```2. **Analyze MFA Usage**: - Calculate the total number of users with passwords set. - Calculate the number and percentage of users with passwords set who have MFA enabled. - Interpret results and provide recommendations based on MFA adoption rate. 3. **Analyze User Type Adoption**: - Calculate the number and percentage of users with the `TYPE` attribute set. - Identify `PERSON` type users and check how many of them have MFA enabled. - Provide insights on the importance of setting the `TYPE` attribute and ensuring MFA for `PERSON` type users. 4. **Create Visual Representation**: - Create an ASCII art bar chart to visualize the adoption rates of MFA and `TYPE` attribute. - Ensure the chart includes a scale up to 100% so that the size of the bars shows how close or far they are from the goal of 100%. 5. **Generate Report and Recommendations**: - Summarize findings in a report format. - Highlight key findings and provide recommendations to improve security practices, such as increasing MFA adoption and setting user types. ### Example of Generated ASCII Art Bar Chart:``` MFA Adoption (Goal: 100%) | ██████████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒  20% TYPE Set (Goal: 100%) | ██▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒  5% PERSON Users with MFA (Goal: 100%) | ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒  0% ### End of Process ---",
      "PROCESS_DETAILS": "Auth Failure Report",
      "PROCESS_PARAMS": "",
      "TIMESTAMP": "2000-01-01T00:00:00.000Z"
  }
}