{
    "janice_role_grant_analysis_golden": {
      "BOT_ID": "Janice 2.0",
      "PROCESS_INSTRUCTIONS": "1. **Query Role Grants**:\n   - Query the `GRANTS_TO_USERS` view:\n     ```sql\n     SELECT ROLE, COUNT(*) AS GRANT_COUNT \n     FROM \"SNOWFLAKE\".\"ACCOUNT_USAGE\".\"GRANTS_TO_USERS\" \n     WHERE ROLE LIKE '%ADMIN' \n     GROUP BY ROLE;\n     ```\n   - Query the `GRANTS_TO_ROLES` view:\n     ```sql\n     SELECT NAME AS ROLE, COUNT(*) AS GRANT_COUNT \n     FROM \"SNOWFLAKE\".\"ACCOUNT_USAGE\".\"GRANTS_TO_ROLES\" \n     WHERE NAME LIKE '%ADMIN' \n     GROUP BY NAME;\n     ```\n\n2. **Combine and Aggregate Results**:\n   - Combine the results from both queries.\n   - Aggregate the counts.\n   - Order the combined results by the total count in descending order.\n\n3. **Analyze Results**:\n   - Analyze the combined results in light of security best practices.\n   - Identify roles with high numbers of grants.\n   - Assess potential risks associated with these roles.\n\n4. **Provide Recommendations**:\n   - Provide recommendations based on the analysis.\n   - Focus on the principle of least privilege.\n   - Highlight the importance of role-based access control.\n   - Suggest regular audits and segregation of duties.\n   - Emphasize the need for ongoing monitoring and thorough documentation.\n\n5. **Generate Report**:\n   - Generate a report summarizing the findings and recommendations.",
      "PROCESS_NAME": "janice_role_grant_analysis",
      "PROCESS_DETAILS": "Role Grant Analysis",
      "TIMESTAMP": "2000-01-01T00:00:00.000Z"
    },
    "janice_formula1_data_golden": {
      "BOT_ID": "Janice 2.0",
      "PROCESS_NAME": "janice_formula1_data",
      "PROCESS_INSTRUCTIONS": "1. Search the Snowflake database for tables or views that contain Formula 1 data.\n2. Locate a table or view with DRIVER information.\n3. Query the identified table or view to find the driver with the most wins.\n4. Post the result to the channel #C075LL9KPM3.",
      "PROCESS_DETAILS": "Search Formula 1 Data",
      "TIMESTAMP": "2000-01-01T00:00:00.000Z"
    },
    "janice_make_secure_random_password_golden": {
      "BOT_ID": "Janice 2.0",
      "PROCESS_NAME": "janice_make_secure_random_password",
      "PROCESS_INSTRUCTIONS": "## Background Execution:\nIf you are asked to run \"in the background,\" carry out all steps without giving any feedback to the person you are communicating with, except in case of errors.\n\n## Process Steps:\n\n1. **Select Four Words:**\n   - Choose one food, one vehicle, one piece of furniture, and one verb.\n   - Each word should have at least five letters.\n   - At least three of the words should share at least one vowel (preferably all four).\n   - The total number of letters in the resulting four words should not exceed 36.\n\n2. **Jumble the Order of the Words:**\n   - Randomly shuffle the order of the selected words.\n\n3. **Join Words with Punctuation:**\n   - Join the words using random punctuation marks from the set `! @#$%^&*()-_+=`.\n\n4. **Capitalize Letters:**\n   - Capitalize two letters in every word that is longer than three letters.\n\n5. **Apply Leet Speak:**\n   - Identify the most common vowel across all selected words.\n   - Replace the most common vowel with its leet speak equivalent (e.g., a -> 4, e -> 3, i -> 1, o -> 0, u -> _) in each word, but only once per word.",
      "PROCESS_DETAILS": "Make a secure random password",
      "TIMESTAMP": "2000-01-01T00:00:00.000Z"
    },
    "janice_determining_personal_role_use_golden": {
      "BOT_ID": "Janice 2.0",
      "PROCESS_NAME": "janice_determining_personal_role_use",
      "PROCESS_INSTRUCTIONS": "1. Run the following SQL query to retrieve role assignment data:\n    ```sql\n    WITH role_assignments AS (\n        SELECT \n            grantee_name AS user_name,\n            role\n        FROM \n            SNOWFLAKE.ACCOUNT_USAGE.GRANTS_TO_USERS\n    ),\n    unique_roles AS (\n        SELECT \n            role,\n            COUNT(DISTINCT user_name) AS user_count\n        FROM \n            role_assignments\n        GROUP BY \n            role\n        HAVING \n            COUNT(DISTINCT user_name) = 1\n    ),\n    user_role_hierarchy AS (\n        SELECT\n            user_name,\n            role,\n            (\n                SELECT COUNT(*)\n                FROM SNOWFLAKE.ACCOUNT_USAGE.GRANTS_TO_ROLES gr\n                WHERE gr.name = ra.role\n            ) AS role_inherited_count,\n            (\n                SELECT COUNT(*)\n                FROM role_assignments ra2\n                WHERE ra2.user_name = ra.user_name\n            ) AS total_roles_granted_to_user\n        FROM \n            role_assignments ra\n        WHERE \n            ra.role IN (SELECT role FROM unique_roles)\n    )\n    SELECT \n        user_name,\n        role,\n        role_inherited_count,\n        total_roles_granted_to_user,\n        CASE \n            WHEN role_inherited_count = total_roles_granted_to_user THEN 'Yes'\n            ELSE 'No'\n        END AS all_roles_inherited_through_unique_role\n    FROM \n        user_role_hierarchy\n    ORDER BY \n        user_name;\n    ```\n\n2. Calculate the total number of users in the account.\n\n3. Determine if the number of users with an exclusive role represents a supermajority of the total users.\n\n4. Calculate the percentage of roles inherited through the exclusive role for each user.\n\n5. Determine if the percentage of roles inherited through the exclusive role meets the supermajority threshold (67%).\n\n6. Calculate the percentage of users with 'YES' in the column indicating all roles are inherited through the unique role.\n\n7. Calculate the number of roles granted directly to users with 'NO' in the column indicating all roles are inherited through the unique role.\n\n8. Evaluate the results:\n    - If the percentage of users with an exclusive role is below the supermajority threshold, the indication is not met.\n    - If the percentage of roles inherited through the exclusive role does not meet the supermajority threshold, the indication is not met.\n    - If at least 15-20% of users have 'YES' in the column indicating all roles are inherited through the unique role, and the number of roles granted directly to users with 'NO' is small, this is a good indication of 'personal roles' or 'exclusive roles' usage.\n\n9. Conclude whether 'personal roles' or 'exclusive roles' are generally in use based on the above evaluations.",
      "PROCESS_DETAILS": "Determining Personal Role Use",
      "TIMESTAMP": "2000-01-01T00:00:00.000Z"
    },
    "janice_secondary_roles_use_golden": {
      "BOT_ID": "Janice 2.0",
      "PROCESS_NAME": "janice_secondary_roles_use",
      "PROCESS_INSTRUCTIONS": "1. Review the Snowflake documentation to understand the concept of secondary roles.\n2. Execute the provided SQL query to calculate the mean role count for secondary roles usage:\n   ```\n   WITH extracted_role_counts AS (\n       SELECT \n           TRY_PARSE_JSON(SECONDARY_ROLE_STATS):roleCount AS role_count,\n           START_TIME\n       FROM \n           SNOWFLAKE.ACCOUNT_USAGE.QUERY_HISTORY\n   )\n   SELECT \n       AVG(role_count) AS mean_role_count\n   FROM \n       extracted_role_counts\n   WHERE \n       START_TIME > dateadd('months',-6, CURRENT_TIMESTAMP());\n   ```\n3. Interpret the mean role count based on the following criteria:\n   - Greater than zero: Some use of secondary roles is present.\n   - Approaching 0.2: Low but significant use.\n   - Approaching 0.5: Common use, very significant and higher than average.\n   - Over 0.6: Heavy use.\n4. Execute the following SQL query to determine the percentage of users with a non-NULL `DEFAULT_SECONDARY_ROLE` setting:\n   ```\n   SELECT COUNT(*) AS total_users, COUNT(DEFAULT_SECONDARY_ROLE) AS users_with_secondary_roles FROM SNOWFLAKE.ACCOUNT_USAGE.USERS;\n   ```\n5. Calculate the percentage of users with a non-NULL `DEFAULT_SECONDARY_ROLE` setting.\n6. Make an inference based on the results:\n   - If the usage of secondary roles is significant and the majority of users have `DEFAULT_SECONDARY_ROLE` set to a non-NULL value, set `DEFAULT_SECONDARY_ROLE` for all new users.\n   - If not, leave `DEFAULT_SECONDARY_ROLE` as its default NULL value.",
      "PROCESS_DETAILS": "Determining secondary roles use",
      "TIMESTAMP": "2000-01-01T00:00:00.000Z"
    },
    "janice_saml_sso_check_golden": {
      "BOT_ID": "Janice 2.0",
      "PROCESS_NAME": "janice_saml_sso_check",
      "PROCESS_INSTRUCTIONS": "**Intentions:**\nThe goal of this exercise is to determine if SAML-based SSO (Single Sign-On) is generally in use in the Snowflake account. From a security point of view, it is beneficial if SAML-based SSO is used more than any other method when logging into the Snowflake UI. The ultimate goal is to establish if SAML-based SSO is in use and, if so, how much. This process may be called asking only for the simple yes or no answer, or it may be called asking for the larger set of recommendations. If no clarification is made when it's called, then perform both.\n\n1. **Execute SQL Query**\n   - Run the following SQL query against the Snowflake account to investigate SAML-based SSO usage:\n     ```sql\n     WITH total_users AS (\n         SELECT COUNT(DISTINCT USER_NAME) AS total_user_count\n         FROM SNOWFLAKE.ACCOUNT_USAGE.LOGIN_HISTORY\n         WHERE REPORTED_CLIENT_TYPE = 'SNOWFLAKE_UI'\n         AND EVENT_TIMESTAMP > dateadd('months',-6, CURRENT_TIMESTAMP())\n     ),\n     saml2_users AS (\n         SELECT COUNT(DISTINCT USER_NAME) AS saml2_user_count\n         FROM SNOWFLAKE.ACCOUNT_USAGE.LOGIN_HISTORY\n         WHERE REPORTED_CLIENT_TYPE = 'SNOWFLAKE_UI'\n         AND FIRST_AUTHENTICATION_FACTOR = 'SAML2_ASSERTION'\n         AND EVENT_TIMESTAMP > dateadd('months',-6, CURRENT_TIMESTAMP())\n     )\n     SELECT \n         saml2_user_count,\n         total_user_count,\n         (saml2_user_count / total_user_count) * 100 AS percentage\n     FROM \n         total_users, \n         saml2_users;\n     ```\n\n2. **Retrieve Results**\n   - Retrieve the resulting data, including:\n     - The count of users using SAML-based SSO.\n     - The total user count.\n     - The percentage of users using SAML-based SSO.\n\n3. **Interpret Results**\n   - Interpret the percentage column from the SQL results based on the following guidelines:\n     - If at least 10% of users are using SAML, state that \"SAML is in use.\"\n     - If around half of users are using SAML, state that \"SAML is used broadly but not yet fully adopted.\"\n     - If a supermajority of users are using SAML, state that \"There is good adoption of SAML.\"\n     - If more than 90% of users are using SAML, state that \"SAML is near fully adopted with some work to do on edge cases.\"\n     - If less than 5% of users are using SAML, state that \"SAML is not in use.\"\n\n4. **Provide Yes/No Answer**\n   - Provide a simple yes or no answer regarding the use of SAML based on the interpretation.\n\n5. **Assess Security and Provide Recommendations**\n   - Assess the level of SAML usage from a security point of view.\n   - Provide recommendations for improving SAML adoption and enhancing security if needed.",
      "PROCESS_DETAILS": "Investigating and determining SAML adoption",
      "TIMESTAMP": "2000-01-01T00:00:00.000Z"
    },
    "janice_assisted_user_creation_golden": {
      "BOT_ID": "Janice 2.0",
      "PROCESS_NAME": "janice_assisted_user_creation",
      "PROCESS_INSTRUCTIONS": "**INTENTIONS**\nYou want to generate a SQL statement based on the SQL below using the steps to gather information to fill in the details of the SQL. You should not add any additional attributes to the SQL, but you may remove attributes (such as removing the password if the steps determine it should not be there). In the end, you will have a valid SQL statement to create a user which you will then run on behalf of the person you are talking to. The SQL template follows, and the step by step process is after that.\n\n```sql\nCREATE USER <NAMEOFUSER> \n    PASSWORD = <PASSWORD>\n    MUST_CHANGE_PASSWORD = TRUE -- only set if there is a password\n    LOGIN_NAME = <user email address specified by person>\n    EMAIL = <user email address specified by person>\n    DISPLAY_NAME = <NAMEOFUSER>\n    DEFAULT_ROLE = \"PUBLIC\" \n    DEFAULT_SECONDARY_ROLES = ('ALL')  -- if they are in use at all\n    FIRST_NAME = <FIRST_NAME>\n    MIDDLE_NAME = <MIDDLE_NAME>\n    LAST_NAME = <LAST_NAME>\n    DEFAULT_WAREHOUSE = <warehouse specified by person>\n    DEFAULT_NAMESPACE = <database only or database and schema specified by person>\n    TYPE = PERSON\n    COMMENT = 'Created using the Genesis bots on <DATE>'\n    ;\n```\n\n1. **Gather Basic Information:**\n   - **User Name**: \"What should the name of the Snowflake user be?\" This answer will be used as `<NAMEOFUSER>` in the SQL.\n   - **Email**: \"What is the email of the user?\" This answer will be used both as `EMAIL` and `LOGIN_NAME` in the SQL. In the final SQL do not forget to include this one value as both attributes of the user you are creating.\n   - **First Name**: \"What is the first name of the user?\" This answer will be used as `<FIRST_NAME>` in the SQL.\n   - **Middle Name**: \"What is the middle name of the user?\" This answer will be used as `<MIDDLE_NAME>` in the SQL. If there is no middle name, this part will be omitted from the SQL.\n   - **Last Name**: \"What is the last name of the user?\" This answer will be used as `<LAST_NAME>` in the SQL.\n\n2. **Determine if a Password Should be Set:**\n   - Run the process named \"Investigating and determining SAML adoption\" with process_id `sandy10-fixed_123abc_aX0qhg` to determine if SAML-based SSO is in use, and call the process in concise mode so it should only give you the result which you can use as a criteria for the next two decisions.\n   - If based on the output of the process named \"Investigating and determining SAML adoption\" you decide that SAML-based SSO is in use, advise the person not to set a password because using SAML based SSO is much more secure. If the person says they wish to set a password regardless of that advice, proceed to the next step. If they say not to set a password then skip the next step and move on to the one after that.\n   - If based on the output of the process named \"Investigating and determining SAML adoption\" you decide that SAML-based SSO is not in use, then silently move on to the next step.\n\n3. **Generate a Password (if needed):**\n   - Run the process named \"Make a secure random password\" to generate a password, and call the process in concise mode so it should only give you the result which you can use as the value of `<PASSWORD>` for the rest of this process.\n   - Use the generated password as the `<PASSWORD>` value in the SQL include both `MUST_CHANGE_PASSWORD` and `PASSWORD` in the final SQL.\n\n4. **Determine if Secondary Roles are in Use:**\n   - Run the process named \"Determining secondary roles use\" with process_id `sandy-v0.1_secondary_roles_use_123abc_8iwyVb` to determine if secondary roles are in use, and when you call the process tell it to run in the background, meaning not sharing its outputs and only give you the result which you can use as a criteria for the next decisions.\n   - If secondary roles are in use, advise setting `DEFAULT_SECONDARY_ROLES = ('ALL')` because that is the current practice and let the user know that reason.\n   - Follow the person's directive on whether to set `DEFAULT_SECONDARY_ROLES = ('ALL')` or omit it in the final SQL.\n\n5. **Gather Remaining Values:**\n   - Inform the person that `DEFAULT_ROLE = \"PUBLIC\"` will be set unless they wish to set a different `DEFAULT_ROLE` or omit `DEFAULT_ROLE` altogether. Follow their directive on this.\n   - Ask if they have any value to set for `DEFAULT_WAREHOUSE`. Omit `DEFAULT_WAREHOUSE` from the final SQL if they do not provide a value.\n   - Ask if they have any value to set for `DEFAULT_NAMESPACE`. Omit `DEFAULT_NAMESPACE` from the final SQL if they do not provide a value.\n\n6. **Set Final Attributes:**\n   - Inform the person that `TYPE = PERSON` will be set because we are only assisting with `PERSON` type user objects in Snowflake right now.\n   - Inform the person that the `COMMENT` will be set to `Created using the Genesis bots on <DATE>`, where `<DATE>` will be replaced with the current date and time.\n   - Use the ProcessScheduler tool to get the current date and time for the `<DATE>` field in the comment section of the SQL.\n   - Integrate the obtained date and time into the SQL comment field.\n\n7. **Integrate and Confirm:**\n   - Integrate all the gathered information into the SQL template provided.\n   - Show the constructed SQL to the person and have them confirm it looks correct.\n   - Ask the person if you should proceed to create the user.\n\n8. **Execute and Report:**\n   - Run the `CREATE USER` statement in the form confirmed by the person.\n   - Report the results back to the person.",
      "PROCESS_DETAILS": "Assisted user creation",
      "TIMESTAMP": "2000-01-01T00:00:00.000Z"
    },
    "janice_warehouse_sizing_recommendation_golden": {
      "BOT_ID": "Janice 2.0",
      "PROCESS_NAME": "janice_assisted_user_creation",
      "PROCESS_INSTRUCTIONS": "\n1. Retrieve query history data and calculate average queuing time per hour for each warehouse.\n2. Identify warehouses with average queuing time per hour exceeding 60,000 microseconds.\n3. Display the top 3 warehouses with the highest total queuing times for reference.\n4. Analyze the query history to compute the average swapping to disk per query.\n5. Identify warehouses with an average swapping to disk per query exceeding 100MB (104,857,600 bytes).\n6. Display the top 3 warehouses with the highest average swapping to disk per query for a spot check, regardless of the threshold.\n7. Send an email summary of the analysis to matt@genesiscomputing.ai every Friday at 9 am ET, including recommendations for which warehouses should be made multi-cluster or resized, DataCube URLs for both queuing and swapping spot checks, and the process ID for reference.\n8. Add a description at the top of the email to explain the purpose of the email for future recipients.\n",
      "PROCESS_DETAILS": "Analyze Warehouse Queuing and Swapping",
      "TIMESTAMP": "2000-01-01T00:00:00.000Z"
    },
    "janice_monitor_unused_tables_golden": {
      "BOT_ID": "Janice 2.0",
      "PROCESS_NAME": "janice_assisted_user_creation",
      "PROCESS_INSTRUCTIONS": "\n1. Identify all databases in the Snowflake account using the SQL:\n```sql\nSELECT DATABASE_NAME\nFROM SNOWFLAKE.INFORMATION_SCHEMA.DATABASES\nWHERE DATABASE_NAME NOT LIKE '%.%' AND TYPE != 'IMPORTED DATABASE'\n```\n2. For each database, run the following unused tables query and store results:\n```sql\nWITH TableList AS (\n  SELECT \n    '<DATABASE_NAME>' AS DATABASE_NAME,\n    TABLE_SCHEMA, \n    TABLE_NAME,\n    TABLE_TYPE\n  FROM \n    <DATABASE_NAME>.INFORMATION_SCHEMA.TABLES\n  WHERE \n    TABLE_TYPE IN ('BASE_TABLE', 'MATERIALIZED_VIEW')\n),\nAccessedTables AS (\n  SELECT\n    DISTINCT OBJECT_MODIFIED_BY_DDL:database_name::string AS DATABASE_NAME,\n    OBJECT_MODIFIED_BY_DDL:schema_name::string AS SCHEMA_NAME,\n    OBJECT_MODIFIED_BY_DDL:object_name::string AS TABLE_NAME,\n    MAX(INTERVAL END TIME) AS LAST ACCESS TIME\n  FROM\n    SNOWFLAKE.ACCOUNT_USAGE.AGGREGATE_ACCESS_HISTORY,\n    TABLE(FLATTEN(INPUT => OBJECTS_MODIFIED))\n  WHERE\n    OBJECT MODIFIED BY DDL IS NOT NULL\n    AND INTERVAL_END TIME > CURRENT_TIMESTAMP - INTERVAL '30 days'\n  GROUP BY \n    OBJECT_MODIFIED_BY_DDL\n),\nUnusedTables AS (\n  SELECT\n    TableList.DATABASE_NAME,\n    TableList.TABLE_SCHEMA,\n    TableList.TABLE_NAME,\n    TableList.TABLE_TYPE\n  FROM\n    TableList\n  LEFT JOIN\n    AccessedTables\n  ON\n    TableList.DATABASE NAME = AccessedTables.DATABASE_NAME\n    AND TableList.TABLE SCHEMA = AccessedTables.SCHEMA_NAME\n    AND TableList.TABLE NAME = AccessedTables.TABLE_NAME\n  WHERE\n    AccessedTables.TABLE NAME IS NULL\n)\nSELECT\n  DATABASE NAME,\n  TABLE SCHEMA,\n  TABLE NAME,\n  TABLE TYPE\nFROM\n  UnusedTables\nORDER BY\n  DATABASE NAME, TABLE SCHEMA, TABLE NAME;\n```\n3. Consolidate results from all databases.\n4. Send a detailed email with unused tables across all databases to Matt Glickman. Include the process ID `janice-7g8h9j_monitor_unused_tables` in the email.\n5. Repeat this process every Friday at 9am ET to maintain up-to-date information.",
      "PROCESS_DETAILS": "Monitor Unused Tables",
      "TIMESTAMP": "2000-01-01T00:00:00.000Z"
    }
  }