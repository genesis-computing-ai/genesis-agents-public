


toolstr = """
[{'type': 'function', 'function': {'name': '_send_slack_direct_message', 'description': 'Send a direct message to a colleague on slack.  Only use this when directed to by a user.  DO NOT USE THIS TO RESPOND TO A REGULAR THREAD.', 'parameters': {'type': 'object', 'properties': {'slack_user_id': {'type': 'string', 'description': "The slack user id to send a message to. Use _lookup_slack_user_id first to confirm the Slack ID of the user. ONLY USE THIS TO REACH OUT TO USERS YOU'RE NOT CURRENTLY TALKING TO, NOT TO RESPOND TO GENERAL CHAT THREADS"}, 'message': {'type': 'string', 'description': 'The text of the message to send directly to the user that you are not already talking to in the conversation thread.  Include any links to local documents referencing ./downloaded_files or the openAI file id.'}}, 'required': ['slack_user_id', 'message']}}}, {'type': 'function', 'function': {'name': '_send_slack_channel_message', 'description': 'Send a message to a specified Slack channel.', 'parameters': {'type': 'object', 'properties': {'channel': {'type': 'string', 'description': "The NAME or ID of the channel to send the message to, e.g. #channel or C07FBCHFZ26.  Make sure you are sending to the channel specified by the user, don't make up channels, and don't default to #general."}, 'message': {'type': 'string', 'description': 'The text of the message to be sent to the channel.  Include any links to local documents referencing ./downloaded_files or the openAI file id.'}}, 'required': ['channel', 'message']}}}, {'type': 'function', 'function': {'name': '_lookup_slack_user_id', 'description': "Lookup the slack user id for a user based on their name.  Only use this if you don't know the slack_id of a user already, and only if you need to send that user a direct message or tag them in a message.", 'parameters': {'type': 'object', 'properties': {'user_name': {'type': 'string', 'description': 'Name of the user to find the slack user id for.'}}, 'required': ['user_name']}}}, {'type': 'function', 'function': {'name': 'make_baby_bot', 'description': 'Creates a new bot with the specified parameters and logs the creation event.  Only use this when instructed to do so by a user. BE SURE TO RECONFIRM AND DOUBLE CHECK ALL THE PARAMETERS WITH THE END USER BEFORE RUNNING THIS TOOL!', 'parameters': {'type': 'object', 'properties': {'bot_id': {'type': 'string', 'description': 'The unique identifier for the bot.  Should be the bot_name dash a 6 letter alphanumeric random code, for example mybot-w73hxg. Generate this yourself dont ask the user for it.'}, 'bot_name': {'type': 'string', 'description': 'The name of the bot.'}, 'bot_instructions': {'type': 'string', 'description': "Instructions for the bot's operation. Defaults to 'You are a helpful bot.'", 'default': 'You are a helpful bot.'}, 'available_tools': {'type': 'string', 'description': "A comma-separated list of tools the new bot shoulf have access to, if any.  Example of a valid string for this field: 'slack_tools,database_tools,image_tools'. Suggest those 3 tools for most bots you make. Use the get_available_tools tool to get a list of the tools that can be referenced here. ", 'default': ''}, 'runner_id': {'type': 'string', 'description': "The identifier for the server that will serve this bot. Only set this if directed specifically by the user, otherwise don't include it."}, 'activate_slack': {'type': 'string', 'description': 'Set to Y to activate the bot on Slack, if possible.  Set to N to specifically NOT activate on Slack.  Only set to N if specified by the user.  Default is Y.'}, 'confirmed': {'type': 'string', 'description': 'Use this only if instructed by a response from this bot.  DO NOT SET IT AS CONFIRMED UNTIL YOU HAVE GONE BACK AND DOUBLECHECKED ALL PARAMETERS WITH THE END USER IN YOUR MAIN THREAD.'}, 'files': {'type': 'string', 'description': 'a commma-separated list of files to be available to the bot, they must first be added to the Internal Bot File Stage'}, 'bot_implementation': {'type': 'string', 'description': "The implementation type for the bot. Examples include 'openai', 'cortex', or custom implementations."}, 'slack_access_open': {'type': 'boolean', 'description': 'True if when deployed to Slack, any Slack user should be able to access the bot, or False if initially no users should have access until explicitly granted using _modify_slack_allow_list.'}}, 'required': ['bot_id', 'bot_name', 'bot_instructions', 'slack_access_open']}}}, {'type': 'function', 'function': {'name': 'get_available_tools', 'description': 'Retrieves the list of tools that a bot can assign to baby bots when using make_baby_bot.  This is NOT the list of tools that you have access to yourself right now, that is in your system prompt.'}}, {'type': 'function', 'function': {'name': '_remove_bot', 'description': 'Deletes a bot with the specified bot_id and cleans up any resources it was using.  USE THIS VERY CAREFULLY, AND DOUBLE-CHECK WITH THE USER THE DETAILS OF THE BOT YOU PLAN TO DELETE BEFORE CALLING THIS FUNCTION.', 'parameters': {'type': 'object', 'properties': {'bot_id': {'type': 'string', 'description': 'The unique identifier for the bot to be deleted.  BE SURE TO CONFIRM THIS WITH THE USER!  Use the list_all_bots tool to figure out the bot_id.'}, 'confirmed': {'type': 'string', 'description': 'Use this only if instructed by a response from this bot.'}}, 'required': ['bot_id']}}}, {'type': 'function', 'function': {'name': 'list_all_bots', 'description': 'Lists all the bots being served by the system, including their bot_ids, slack_user_id, runner IDs, names, instructions, tools, auth_url, etc.  This is useful to find information about a bot, or to search for a particular bot.', 'parameters': {'type': 'object', 'properties': {'with_instructions': {'type': 'boolean', 'description': "If true, includes the bot's full instructions in the result. Use this to know what the bot's role is and what it does. Defaults to false.", 'default': False}}}}}, {'type': 'function', 'function': {'name': '_deploy_to_slack', 'description': 'Deploys an existing bot to Slack', 'parameters': {'type': 'object', 'properties': {'bot_id': {'type': 'string', 'description': 'The bot_id to deploy. Use the list_all_bots function if you are unsure of the bot_id.'}}, 'required': ['bot_id']}}}, {'type': 'function', 'function': {'name': 'add_new_tools_to_bot', 'description': "Adds new tools to an existing bot's available_tools list if they are not already present. It is ok to use this to grant tools to yourself if directed.", 'parameters': {'type': 'object', 'properties': {'bot_id': {'type': 'string', 'description': 'The unique identifier for the bot.  Use list_all_bots function if you are unsure of the bot_id.'}, 'new_tools': {'type': 'array', 'items': {'type': 'string'}, 'description': 'A list of new tool names to add to the bot.  Use get_available_tools function to know whats available.'}}, 'required': ['bot_id', 'new_tools']}}}, {'type': 'function', 'function': {'name': 'remove_tools_from_bot', 'description': "Removes tools from an existing bot's available_tools list if they are not already present. It is ok to use this to grant tools to yourself if directed.", 'parameters': {'type': 'object', 'properties': {'bot_id': {'type': 'string', 'description': 'The unique identifier for the bot.  Use list_all_bots function if you are unsure of the bot_id.'}, 'remove_tools': {'type': 'array', 'items': {'type': 'string'}, 'description': 'A list of new tool names to add to the bot.  Use get_available_tools function to know whats available.'}}, 'required': ['bot_id', 'remove_tools']}}}, {'type': 'function', 'function': {'name': 'update_bot_instructions', 'description': 'Updates the bot_instructions for the specified bot_id.', 'parameters': {'type': 'object', 'properties': {'bot_id': {'type': 'string', 'description': 'The unique identifier for the bot.'}, 'new_instructions': {'type': 'string', 'description': 'The new instructions for the bot.'}}, 'required': ['bot_id', 'new_instructions']}}}, {'type': 'function', 'function': {'name': 'add_bot_files', 'description': 'Adds to the files list for the specified bot_id by adding new files if they are not already present.', 'parameters': {'type': 'object', 'properties': {'bot_id': {'type': 'string', 'description': 'The unique identifier for the bot.'}, 'new_file_names': {'type': 'array', 'items': {'type': 'string'}, 'description': 'A list of the filenames from the Internal File Stage for Bots to assign to the bot. A file_name can optionally be a wildcard representing a whole folder of files within the stage, such as bot_1_files/*. When adding with wildcards, do NOT add each file separately.'}}, 'required': ['bot_id', 'new_file_names']}}}, {'type': 'function', 'function': {'name': 'remove_bot_files', 'description': 'Removes files from the files list for the specified bot_id if they are present.', 'parameters': {'type': 'object', 'properties': {'bot_id': {'type': 'string', 'description': 'The unique identifier for the bot.'}, 'file_ids_to_remove': {'type': 'array', 'items': {'type': 'string'}, 'description': 'A list of the filenames from the Internal File Stage for Bots to remove from the bot. A file_id can optionally be a wildcard representing a whole folder of files within the stage, such as bot_1_files/*'}}, 'required': ['bot_id', 'file_ids_to_remove']}}}, {'type': 'function', 'function': {'name': 'update_app_level_key', 'description': 'Updates the Slack app level key for a specific bot after verifying it is a valid app level token.', 'parameters': {'type': 'object', 'properties': {'bot_id': {'type': 'string', 'description': 'The unique identifier for the bot.'}, 'slack_app_level_key': {'type': 'string', 'description': 'The new Slack app level key to set for the bot.'}}, 'required': ['bot_id', 'slack_app_level_key']}}}, {'type': 'function', 'function': {'name': '_update_bot_implementation', 'description': 'Updates the implementation type for a specific bot, to change the LLM that a bot uses.', 'parameters': {'type': 'object', 'properties': {'bot_id': {'type': 'string', 'description': 'The unique identifier for the bot. Use list_all_bots to get this identifier, it is not just the bots name.'}, 'bot_implementation': {'type': 'string', 'description': "The new implementation type to be set for the bot. Valid options include 'openai', 'cortex'."}}, 'required': ['bot_id', 'bot_implementation']}}}, {'type': 'function', 'function': {'name': '_modify_slack_allow_list', 'description': 'Modifies the SLACK_USER_ALLOW list for a bot to specify who can access it on Slack. First ensure that SLACK_ACTIVE for the bot is True using list_all_bots.', 'parameters': {'type': 'object', 'properties': {'bot_id': {'type': 'string', 'description': 'The unique identifier for the bot.'}, 'action': {'type': 'string', 'description': 'The action to perform - LIST current users that have access, GRANT to a user, or REVOKE from a user. Or GRANT ALL to allow any Slack user to use the bot, or REVOKE ALL to allow no users to use the bot.  If all users have access currently simply call GRANT to a single user to revoke everyone else, no need to also call REVOKE ALL.'}, 'user_identifier': {'type': 'string', 'description': "The Slack user ID (starts with 'U') GRANT or REVOKE access. Provide this OR the user_name field instead if you dont know the ID.", 'default': None}, 'user_name': {'type': 'string', 'description': 'The full name to GRANT or REVOKE access.  This looks up the Slack ID based on the full first and last name. Provide this OR user_identifier.', 'default': None}}, 'required': ['bot_id', 'action']}}}, {'type': 'function', 'function': {'name': '_list_stage_contents', 'description': 'Lists the contents of a given Snowflake stage, up to 50 results (use pattern param if more than that). Run SHOW STAGES IN SCHEMA <database>.<schema> to find stages.', 'parameters': {'type': 'object', 'properties': {'database': {'type': 'string', 'description': 'The name of the database.'}, 'schema': {'type': 'string', 'description': 'The name of the schema.'}, 'stage': {'type': 'string', 'description': 'The name of the stage to list contents for.'}, 'pattern': {'type': 'string', 'description': 'An optional regex pattern to limit the search for example /bot1_files/.* or document_.*'}}, 'required': ['database', 'schema', 'stage']}}}, {'type': 'function', 'function': {'name': '_add_file_to_stage', 'description': 'Uploads a file from an OpenAI FileID to a Snowflake stage. Replaces if exists.', 'parameters': {'type': 'object', 'properties': {'database': {'type': 'string', 'description': 'The name of the database. Use your WORKSPACE database unless told to use something else.'}, 'schema': {'type': 'string', 'description': 'The name of the schema.  Use your WORKSPACE schema unless told to use something else.'}, 'stage': {'type': 'string', 'description': 'The name of the stage to add the file to. Use your WORKSPACE stage unless told to use something else.'}, 'openai_file_id': {'type': 'string', 'description': 'A valid OpenAI FileID referencing the file to be loaded to stage.'}, 'file_name': {'type': 'string', 'description': 'The original filename of the file, human-readable, NOT file-xxxx. Can optionally include a relative path, such as bot_1_files/file_name.txt'}}, 'required': ['database', 'schema', 'stage', 'openai_file_id', 'file_name']}}}, {'type': 'function', 'function': {'name': '_read_file_from_stage', 'description': 'Reads a file from a Snowflake stage.', 'parameters': {'type': 'object', 'properties': {'database': {'type': 'string', 'description': 'The name of the database.'}, 'schema': {'type': 'string', 'description': 'The name of the schema.'}, 'stage': {'type': 'string', 'description': 'The name of the stage to read the file from.'}, 'file_name': {'type': 'string', 'description': 'The name of the file to be read.'}, 'return_contents': {'type': 'boolean', 'description': 'Whether to return the contents of the file or just the file name.', 'default': True}, 'is_binary': {'type': 'boolean', 'description': 'Whether to return the contents of the file as binary or text.', 'default': False}}, 'required': ['database', 'schema', 'stage', 'file_name']}}}, {'type': 'function', 'function': {'name': '_delete_file_from_stage', 'description': 'Deletes a file from a Snowflake stage.', 'parameters': {'type': 'object', 'properties': {'database': {'type': 'string', 'description': 'The name of the database.'}, 'schema': {'type': 'string', 'description': 'The name of the schema.'}, 'stage': {'type': 'string', 'description': 'The name of the stage to delete the file from.'}, 'file_name': {'type': 'string', 'description': 'The name of the file to be deleted.'}}, 'required': ['database', 'schema', 'stage', 'file_name']}}}, {'type': 'function', 'function': {'name': '_analyze_image', 'description': 'Generates a textual description of an image.', 'parameters': {'type': 'object', 'properties': {'query': {'type': 'string', 'description': 'The question about the image.'}, 'openai_file_id': {'type': 'string', 'description': 'The OpenAI file ID of the image.'}, 'file_name': {'type': 'string', 'description': 'The name of the image file.'}}, 'required': ['query', 'openai_file_id', 'file_name']}}}, {'type': 'function', 'function': {'name': '_generate_image', 'description': "Generates an image using OpenAI's DALL-E 3. Use this only to make pictures. To make PDFs or files, use Snowpark not this.", 'parameters': {'type': 'object', 'properties': {'prompt': {'type': 'string', 'description': 'Description of the image to create.'}}, 'required': ['prompt']}}}, {'type': 'function', 'function': {'name': '_manage_processes', 'description': 'Manages processes for bots, including creating, updating, listing and deleting processes allowing bots to manage processes.  Remember that this is not used to create new bots', 'parameters': {'type': 'object', 'properties': {'action': {'type': 'string', 'description': "\n                        The action to perform on a process: CREATE, UPDATE, DELETE, CREATE_PROCESS_CONFIG, UPDATE_PROCESS_CONFIG, DELETE_PROCESS_CONFIG.  \n                        LIST returns a list of all processes, SHOW shows full instructions and details for a process, SHOW_CONFIG shows the configuration for a process,\n                        or TIME to get current system time.  If you are trying to deactivate a schedule for a task, use _process_scheduler instead, don't just DELETE the porocess."}, 'bot_id': {'type': 'string', 'description': 'The identifier of the bot that is having its processes managed.'}, 'process_id': {'type': 'string', 'description': 'The unique identifier of the process, create as bot_id_<random 6 character string>. MAKE SURE TO DOUBLE-CHECK THAT YOU ARE USING THE CORRECT process_id ON UPDATES AND DELETES!  Required for CREATE, UPDATE, and DELETE.'}, 'process_details': {'type': 'object', 'description': 'The details of the process, required for create and update actions.', 'properties': {'process_name': {'type': 'string', 'description': 'The name of the process. Required for SHOW.'}, 'process_instructions': {'type': 'string', 'description': 'DETAILED instructions for completing the process  Do NOT summarize or simplify instructions provided by a user.'}, 'process_config': {'type': 'string', 'description': 'Configuration string used by process when running.'}}, 'required': ['process_name']}}, 'required': ['action', 'bot_id']}}}, {'type': 'function', 'function': {'name': '_run_process', 'description': 'Run a process', 'parameters': {'type': 'object', 'properties': {'action': {'type': 'string', 'description': '\n                        The action to perform: KICKOFF_PROCESS, GET_NEXT_STEP.  Either process_name or process_id must also be specified.\n                        '}, 'process_name': {'type': 'string', 'description': 'The name of the process to run'}, 'process_id': {'type': 'string', 'description': 'The id of the process to run (note: this is NOT the task_id or process_schedule_id)'}, 'previous_response': {'type': 'string', 'description': 'The previous response from the bot (for use with GET_NEXT_STEP)'}, 'concise_mode': {'type': 'boolean', 'default': False, 'description': 'Optional, to run in low-verbosity/concise mode. Default to False.'}}, 'required': ['action']}}}, {'type': 'function', 'function': {'name': '_send_email', 'description': 'Sends an email', 'parameters': {'type': 'object', 'properties': {'to_addr_list': {'type': 'array', 'items': {'type': 'string'}, 'description': 'A list of recipient email addresses.'}, 'subject': {'type': 'string', 'description': 'The subject of the email.'}, 'body': {'type': 'string', 'description': 'The body content of the email.'}, 'mime_type': {'type': 'string', 'description': "The MIME type of the email body. Accepts 'text/plain' or 'text/html'. Defaults to 'text/plain'."}}, 'required': ['to_addr_list', 'subject', 'body']}}}, {'type': 'function', 'function': {'name': 'search_metadata', 'description': "Finds available data.  Searches metadata to find the top relevant tables or views in the users database. Use this if you don't already know which tables to query. If you already know the full table name, use get_full_table_details instead. (Note, this does not search stages).", 'parameters': {'type': 'object', 'properties': {'query': {'type': 'string', 'description': 'A short search query of what kind of data the user is looking for.'}, 'top_n': {'type': 'integer', 'description': 'How many of the top results to return, max 25, default 15.  Use 15 to start.', 'default': 15}, 'database': {'type': 'string', 'description': 'Optional, Use when you want to constrain the search to a specific database, only use this when you already know for sure the name of the database.'}, 'schema': {'type': 'string', 'description': 'Optional, Use to constrain the search to a specific schema, only use this when you already know for sure the name of the schema.'}}, 'required': ['query']}}}, {'type': 'function', 'function': {'name': '_run_query', 'description': 'Run a query against a database.  If you need to find tables to query, use search_metadata first to determine the right object names to query.', 'parameters': {'type': 'object', 'properties': {'query': {'type': 'string', 'description': 'The SQL query to run. Be sure to fully qualify all object names with double-quoted 3-part names: "<database>"."<schema>"."<table>".  If the user gives you a query to run without quoted names, use upper case for database, schema, and table names.'}, 'connection': {'type': 'string', 'description': 'The name of the data connection, for example Snowflake.'}, 'max_rows': {'type': 'integer', 'description': 'The maximum number of rows to return.  This can be up to 100. The default is 20.', 'default': 20}, 'note_id': {'type': 'string', 'description': 'The note_id of the note that contains the query to run.  This is an optional field.  If it is provided, the query will be saved in the note.  Use the note contents instead of the query parameter.'}}, 'required': ['query', 'connection', 'max_rows']}}}, {'type': 'function', 'function': {'name': 'get_full_table_details', 'description': 'Gets full verbose details for a specific table including full DDL and sample data.', 'parameters': {'type': 'object', 'properties': {'database': {'type': 'string', 'description': 'The name of the database where the table is located.'}, 'schema': {'type': 'string', 'description': 'The name of the schema where the table is located.'}, 'table': {'type': 'string', 'description': 'The name of the table to retrieve full details for.'}, 'query': {'type': 'string', 'description': 'Always use *.'}}, 'required': ['database', 'schema', 'table', 'query']}}}, {'type': 'function', 'function': {'name': '_run_snowpark_python', 'description': "Executes a string of Python snowflake snowpark code using a precreated and provided 'session', do not create a new session.  Use this instead of code_interpreter when directed to use snowpark, or when you want to run python that can directly interact with the user's snowflake session, tables, and stages.", 'parameters': {'type': 'object', 'properties': {'purpose': {'type': 'string', 'description': 'A detailed explanation in English of what this code is supposed to do. This will be used to help validate and debug your code.'}, 'code': {'type': 'string', 'description': "The Python code to execute in Snowflake Snowpark. The snowpark 'session' is already created and ready for your code's use, do NOT create a new session. Run queries inside of Snowpark versus inserting a lot of static data in the code. Use the full names of any stages with database and schema. If you want to access a file, first save it to stage, and then access it at its stage path, not just /tmp. Always set 'result' variable at the end of the code execution in the global scope to what you want to return. To return a file, save it to /tmp (not root) then base64 encode it and respond like this: image_bytes = base64.b64encode(image_bytes).decode('utf-8')\nresult = { 'type': 'base64file', 'filename': file_name, 'content': image_bytes}. Be sure to properly escape any double quotes in the code."}, 'packages': {'type': 'string', 'description': 'A comma-separated list of required non-default Python packages to be pip installed for code execution (do not include any standard python libraries).'}, 'note_id': {'type': 'string', 'description': 'An id for a note in the notebook table.  The note_id will be used to look up the python code from the note content in lieu of the code field.  A note_id will take precendent over the code field, that is, if the note_id is not empty, the contents of the note will be run instead of the content of the code field.'}}, 'required': ['code', 'purpose']}}}, {'type': 'function', 'function': {'name': '_process_scheduler', 'description': 'Manages schedules to automatically run processes on a schedule (sometimes called tasks), including creating, updating, and deleting schedules for processes.', 'parameters': {'type': 'object', 'properties': {'action': {'type': 'string', 'description': 'The action to perform on the process schedule: CREATE, UPDATE, or DELETE.  Or LIST to get details on all scheduled processes for a bot, or TIME to get current system time or HISTORY to get the history of a scheduled process by task_id.  For history lookup task_id first using LIST.  To deactive a schedule without deleting it, UPDATE it and set task_active to FALSE.'}, 'bot_id': {'type': 'string', 'description': 'The identifier of the bot for which to manage scheduled_processes.'}, 'history_rows': {'type': 'integer', 'description': 'For action HISTORY, how many history rows about runs of the task to return.'}, 'task_id': {'type': 'string', 'description': 'The unique identifier of the process schedule, create as bot_id_<random 6 character string>. MAKE SURE TO DOUBLE-CHECK THAT YOU ARE USING THE CORRECT task_id, its REQUIRED ON CREATE, UPDATES AND DELETES! Note that this is not the same as the process_id'}, 'task_details': {'type': 'object', 'description': 'The properties of this object are the details of the process schedule for use when creating and updating.', 'properties': {'process_name': {'type': 'string', 'description': 'The name of the process to run on a schedule. This must be a valid process name shown by _manage_processes LIST'}, 'primary_report_to_type': {'type': 'string', 'description': 'Set to SLACK_USER'}, 'primary_report_to_id': {'type': 'string', 'description': 'The Slack USER ID of the person who told you to create this schedule for a process.'}, 'next_check_ts': {'type': 'string', 'description': "The timestamp for the next run of the process 'YYYY-MM-DD HH:MM:SS'. Call action TIME to get current time and timezone. Make sure this time is in the future."}, 'action_trigger_type': {'type': 'string', 'description': 'Always set to TIMER'}, 'action_trigger_details': {'type': 'string', 'description': 'For TIMER, a description of when to call the task, eg every hour, Tuesdays at 9am, every morning.  Also be clear about whether the task should be called one time, or is recurring, and if recurring if it should recur forever or stop at some point.'}, 'last_task_status': {'type': 'string', 'description': 'The current status of the scheduled process.'}, 'task_learnings': {'type': 'string', 'description': "Leave blank on creation, don't change on update unless instructed to."}, 'task_active': {'type': 'boolean', 'description': 'TRUE if active, FALSE if not active.  Set to FALSE to Deactivate a schedule for a process.'}}, 'required': ['task_name', 'action_trigger_details', 'last_task_status', 'task_learnings', 'task_active']}}, 'required': ['action', 'bot_id']}}}, {'type': 'function', 'function': {'name': '_get_harvest_control_data', 'description': 'Retrieves all the data from the harvest control table and returns it.  Tells you what sources and databases are being harvested, and if any schemas are being specifically included or excluded.  You can also use get_visible_databases to suggest additional things to harvest.', 'parameters': {}}}, {'type': 'function', 'function': {'name': '_set_harvest_control_data', 'description': 'Inserts or updates a row in the harvest control table using MERGE statement with explicit parameters.  Offer to use get_harvest_control_data to know whats already being harvested, then you can use get_visible_databases and get_visible_schemas tools to help decide what databases and schemas to add or change.', 'parameters': {'type': 'object', 'properties': {'source_name': {'type': 'string', 'description': 'The source name for the harvest control data.  This is probably the current source specified in your system prompt, such as Snowflake. '}, 'database_name': {'type': 'string', 'description': 'The database name for the harvest control data. Offer to the get_databases function to help figure out whats available.  Make sure to set the case properly for the database, either all upper case, or mixed case as reported by get_databases'}, 'initial_crawl_complete': {'type': 'boolean', 'description': 'Flag indicating if the initial crawl is complete.', 'default': False}, 'refresh_interval': {'type': 'integer', 'description': 'The interval at which the data is refreshed in minutes.  Use 5 minutes unless the user specifies otherwise.'}, 'schema_exclusions': {'type': 'array', 'items': {'type': 'string', 'description': 'Name of schema to exclude. The get_schemas function can be used to know what schemas are in a database.  You should suggest excluding the INFORMATION_SCHEMA unless directed to include it, or unless only specfic schemas are being selected using schema_inclusions.'}, 'description': 'A list of schema names to exclude.  Optional.', 'default': []}, 'schema_inclusions': {'type': 'array', 'items': {'type': 'string', 'description': 'Name of schema to include. '}, 'description': 'A list of schema names to include. Leave empty to include All schemas, which is the default.', 'default': []}, 'status': {'type': 'string', 'description': 'The status of the harvest control.', 'default': 'Include'}}, 'required': ['source_name', 'database_name']}}}, {'type': 'function', 'function': {'name': '_remove_harvest_control_data', 'description': 'Removes a row from the harvest control table based on the provided identifiers. Removing this row will stop crawling data for this database.  If the user also wants to remove previously-crawled data for this source, also call _remove_metadata_for_database', 'parameters': {'type': 'object', 'properties': {'source_name': {'type': 'string', 'description': 'The source name for the harvest control data to remove.'}, 'database_name': {'type': 'string', 'description': 'The database name for the harvest control data to remove.'}}, 'required': ['source_name', 'database_name']}}}, {'type': 'function', 'function': {'name': '_remove_metadata_for_database', 'description': 'Removes harvester crawl results for a specific source and database from the metadata table.', 'parameters': {'type': 'object', 'properties': {'source_name': {'type': 'string', 'description': 'The source name for the harvest control data to remove.'}, 'database_name': {'type': 'string', 'description': 'The name of the database for which to remove metadata.'}}, 'required': ['source_name', 'database_name']}}}, {'type': 'function', 'function': {'name': '_get_harvest_summary', 'description': 'Retrieves a summary and statistics of the currently-harvested data.', 'parameters': {}}}, {'type': 'function', 'function': {'name': '_get_visible_databases', 'description': 'Retrieves a list of databases from the current source. Can be used to help the user decide which databases to include in the harvester.', 'parameters': {}}}, {'type': 'function', 'function': {'name': '_get_visible_schemas', 'description': 'Retrieves a list of schemas for a given database from the current source. Helps the user decide what schemas to include or exclude when configuring the harvester.', 'parameters': {'type': 'object', 'properties': {'database': {'type': 'string', 'description': 'The database for which to retrieve the schemas.'}}, 'required': ['database']}}}, {'type': 'function', 'function': {'name': '_get_visible_tables', 'description': 'Retrieves a list of tables for a given schema in a database from the current source.  This is useful if the user wants to know what is in a particular schema.', 'parameters': {'type': 'object', 'properties': {'database': {'type': 'string', 'description': 'The database for which to retrieve the tables.'}, 'schema': {'type': 'string', 'description': 'The schema for which to retrieve the tables.'}}, 'required': ['database', 'schema']}}}, {'type': 'function', 'function': {'name': '_manage_notebook', 'description': 'Manages notes for bots, including creating, updating, listing and deleting notes, allowing bots to manage notebook.  Remember that this is not used to create new bots', 'parameters': {'type': 'object', 'properties': {'action': {'type': 'string', 'description': '\n                        The action to perform on a note: CREATE, UPDATE, DELETE, CREATE_NOTE_CONFIG, UPDATE_NOTE_CONFIG, DELETE_NOTE_CONFIG\n                        LIST returns a list of all notes, SHOW shows all fields of a note,\n                        or TIME to get current system time.'}, 'bot_id': {'type': 'string', 'description': 'The identifier of the bot that is having its processes managed.'}, 'note_id': {'type': 'string', 'description': 'The unique identifier of the note, create as bot_id_<random 6 character string>. MAKE SURE TO DOUBLE-CHECK THAT YOU ARE USING THE CORRECT note_id ON UPDATES AND DELETES!  Required for CREATE, UPDATE, and DELETE.'}, 'note_name': {'type': 'string', 'description': 'Human reable unique name for the note.'}, 'note_type': {'type': 'string', 'description': "The type of note.  Should be 'process', 'snowpark_python', or 'sql'"}, 'note_content': {'type': 'string', 'description': 'The body of the note'}, 'note_params': {'type': 'string', 'description': 'Parameters that are used by the note'}}, 'required': ['action', 'bot_id', 'note_id', 'note_name', 'note_type', 'note_content']}}}]
"""


tools = eval(toolstr)
node_tools = str(tools).replace("'", '"')
print(f"const tools = {node_tools};")

